using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary1
{
    public class Triangle:Root
    {
        private double a;//сторона 1
        private double b;//сторона 2
        private double c;//сторона 3

        public Triangle(double a, double b, double c)//параметрический конструктор
        {
            if (a + b > c)//по геометрическим соображениям третья сторона не может быть больше суммы первых двух
            {
                /* максимальная длина третьей стороны как раз и определяется  если развернуть любые две стороны на 180 градусов, длина третьей стороны должна быть в диапазоне
                [0,a+b], если значение превышено то это не треугольник
                */
                if (a > 0 && b > 0 && c > 0)//так же все стороны долны быть положительными числами
                {
                    if (a > b && a - b < c)//по геометрическим соображениям третья сторона должна дотянуться до вершины ( случай когда a > b )
                    {
                        this.a = a;
                        this.b = b;
                        this.c = c;
                    }
                    else if (a < b && b - a < c)//по геометрическим соображениям третья сторона должна дотянуться до вершины ( случай когда b > a )
                    {
                        this.a = a;
                        this.b = b;
                        this.c = c;
                    }
                    else throw new NotImplementedException();//не дадим ввести некорректные значения (я использовал именно этот эксепшен потому что не знаю какой лучше здесь,
                                                             //лишь бы прервать работу программы)
                }
                else throw new NotImplementedException();//не дадим ввести некорректные значения
            }
            else throw new NotImplementedException();//не дадим ввести некорректные значения
        }

        public override double CalculateArea()//вычислим площадь по трем сторонам(формула Герона)
        {
            double HalfPerimeter = (a + b + c)/2.0;
            return Math.Sqrt(HalfPerimeter * (HalfPerimeter - a) * (HalfPerimeter - b) * (HalfPerimeter - c));
        }

        private bool MyEqualFunction(double one,double two,double error)//функция-предикат для сравнения двух положительных чисел с заданной погрешностью
        {
            if (one > 0 && two > 0)
            {
                if ( Math.Abs(one - two) / (one + two) <= error)/*
                                                                 я вас научу сравнивать с погрешностью, для начала определим что это за формула такая страшная и непонятная?
                                                                 1) если два числа не равны нулю и одно из них во много раз больше другого то "Math.Abs(one - two) / (one + two)" стремится к числу 1
                                                                 2) если два числа не равны нулю и одно из них равно другому то "Math.Abs(one - two) / (one + two)" стремится к числу 0
                                                                 3) вот и выходит что наша погрешность лежит  в интервале ( 0,1 ), чем ближе она к нулю тем качественнее сравнение
                                                                 4) если простым языком, то даже промышленные угольники имеют погрешности, и вы никогда не достигните идеального прямого угла
                                                                 ( это отсылка к нашей задаче, потому что к ней это имеет точно такое же отношение )
                                                                 */
                {
                    return true;
                }
                else return false;
            }
            else return false;
        }

        public bool IsARectangularTriangleMain()/*предикат для проверки треугольника на прямоугольность ( проверка должна быть внутри треугольника который мы проверяем,
                                                  мы же не хотим статик функцию делать и потом туда ссылку на объект передавать не правда ли "это сарказм,
                                                  потому что в прошлый раз кто-то из ваших искренне удивлялся почему этот метод я засунул именно сюда" ?)

            Теперь по делу:
            Основной метод заключается в проверке сторон, дело в том что если прямоугольник треугольный то в нем обязательно должны быть 2 катета,
            эти катеты всегда находятся у одной из вершин, количество вершин равно трем, следовательно нужны 3 проверки. Если мы определили катеты верно,
            то можно вычислить гипотенузу по теореме Пифагора. Если хотябы у одной из вершин вычисленная по Пифагору противолежащая сторона будет равна той,
            что была введена при создании треугольника, то мы нашли где катеты и одновременно подтвердили прямоугольность треугольника, но хочу сказать что знаю какой код вы от меня ждете:

            if ( Math.Sqrt(Math.Pow(a, 2.0) + Math.Pow(b, 2.0)) == c ) return true;
            else if ( Math.Sqrt(Math.Pow(b, 2.0) + Math.Pow(c, 2.0)) == a ) return true;
            else if ( Math.Sqrt(Math.Pow(c, 2.0) + Math.Pow(a, 2.0)) == b ) return true;
            else return false;

            но такой код не верный, ( отсылаю к математике ), с точки зрения математики формула вычисляет точное значение, а с точки зрения практики, лишь приближенно,
            например если возведение в степень дает число 1,333333 а мы ввели в начале 1,3333333333333 ? казалось бы никакой разницы на первый взгляд, но во втором числе
            больше троек после запятой, а в первом меньше ! И такие ошибки могут копиться если одна формула вызывает другую а другая третью и в итоге вы получите false вместо true 
            при сравнении. Именно по этому всегда в таких случаях нужно сравнивать с погрешностью, либо задавать диапазон углов, скажем от 89,5 и до 90,5 ,
            но в этом случае проверка уже будет по углам а не по сторонам.
            */
        {
            //правильный код
            if (MyEqualFunction(Math.Sqrt( Math.Pow(a,2.0) + Math.Pow(b,2.0)), c, 1e-2)) return true;//если катеты находятся при первой вершине
            else if (MyEqualFunction(Math.Sqrt(Math.Pow(b,2.0) + Math.Pow(c,2.0)), a, 1e-2)) return true;//если катеты находятся при второй вершине
            else if (MyEqualFunction(Math.Sqrt(Math.Pow(c,2.0) + Math.Pow(a,2.0)), b, 1e-2)) return true;//если катеты находятся при третьей вершине
            else return false;//если катеты не найдены то треугольник не прямоугольный
        }

        public bool IsARectangularTriangleAlternative()/*
                                                       здесь альтернативный способ проверки на прямоугольность, здесь я использовал функцию которая считает площадь любого треугольника
                                                       ( формула Герона по трем сторонам ), если мы представим что у нас прямоугольный треугольник то эту же площадь можно посчитать по катетам так:
                                                       1/2 * катет1 * катет2     ( это такая же скалярная величина как и сторона треугольника и площадь так же можно брать для сравнения )
                                                       вот я и сравниваю площади вместо сторон, результат будет идентичен, и конечно же так же не забываем о погрешностях
                                                       */
        {
            //если катеты существуют, мы найдем их возле одной из вершин
            if (MyEqualFunction(0.5 * a * b,CalculateArea(),1e-2)) return true;//если катеты находятся при первой вершине
            else if (MyEqualFunction(0.5 * b * c, CalculateArea(), 1e-2)) return true;//если катеты находятся при второй вершине
            else if (MyEqualFunction(0.5 * c * a, CalculateArea(), 1e-2)) return true;//если катеты находятся при третьей вершине
            else return false;//если катеты не найдены то треугольник не прямоугольный
        }
    }
}
